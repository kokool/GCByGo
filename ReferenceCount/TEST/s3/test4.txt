//测试失败原因分析：未知？
package main

import "fmt"

type Object struct {
	No       string
	RefCnt   int
	Data     []byte
	children []*Object
}

func (obj *Object) UpdatePtr(ptr *Object) {
	if ptr == nil {
		return
	}
	ptr.IncRefCnt()
	obj.DecRefCnt()
	obj.children = []*Object{ptr}
}

func (obj *Object) IncRefCnt() {
	obj.RefCnt++
}

func (obj *Object) DecRefCnt() {
	obj.RefCnt--
	if obj.RefCnt == 0 {
		for _, child := range obj.children {
			child.DecRefCnt()
		}
		obj.destroy()
	}
}

func (obj *Object) AddRef(ptr *Object) {
	if ptr == nil {
		return
	}
	obj.children = append(obj.children, ptr)
}

func (obj *Object) destroy() {
	obj.children = nil
	obj.Data = nil
	fmt.Printf("%s has been destroyed\n", obj.No)
}

func main() {
	root := &Object{No: "root", RefCnt: 1, Data: make([]byte, 0)}
	a := &Object{No: "A", RefCnt: 1, Data: make([]byte, 2)}
	b := &Object{No: "B", RefCnt: 1, Data: make([]byte, 2)}
	c := &Object{No: "C", RefCnt: 1, Data: make([]byte, 2)}
	d := &Object{No: "D", RefCnt: 1, Data: make([]byte, 2)}
	root.AddRef(a)
	root.AddRef(c)
	a.AddRef(b)
	b.AddRef(d)
	a.UpdatePtr(c)
	fmt.Println("修改阶段")
	fmt.Println(root)
	fmt.Printf("%p", a)
	fmt.Println(a)
	fmt.Printf("%p", b)
	fmt.Println(b)
	fmt.Printf("%p", c)
	fmt.Println(c)
	fmt.Printf("%p", d)
	fmt.Println(d)
}

//output:
/*

&{B 1 [0 0] [0xc000052190]}
&{D 1 [0 0] []}
D has been destroyed
B has been destroyed
A has been destroyed
修改阶段
&{root 0 [] [0xc0000520a0 0xc000052140]}
&{A 0 [] [0xc000052140]}
//有问题的地方，正确的结果应为{A 1 [0 0] [C address]}，但是因为这是书本伪代码造成的内存泄漏问题，所以不用理会
&{B 0 [] []}
&{C 2 [0 0] []}
&{D 0 [] []}
*/
