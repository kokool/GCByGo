1、看了引用计数那章，提示 mutator 在生成新对象的时候会调用 new_obj() 函数

所以new_obj()函数就是新建对象的函数，那么要修改的内容有：

create_data()函数，意思就是要统一规范自己的活动对象与非活动对象了。

而要达成分配的前提是，堆得有分配的空间，这分配的空间就是一开始所有对象都是非活动对象，大家都没有被分配空间。

伪代码
Init_data(){
    h=new_obj()
    for i := range heap {
		heap[i] = h
	}
    //这里具体划分哪些是活动对象哪些是非活动对象
    h1=new_obj
    //这里则变成了roots指向的对象
}

新问题1：heap

heap必须要有个限定size（域）总数，而不是单纯的heap_size（对象总数），之前init_data()写的heap对象/chunk的size没划分清楚

新问题2：free_list
根据书本的图示，该链表一开始就是指向为null，后面在mark与sweep之后才连上分块，所以 mutator 在生成新对象的函数也得考虑这层因素


总结：我其实要做的就是统一创建新对象的函数，而不是直接写Object{}这样创建数据

先暂时别管分配与合并这个问题，重写init_data创建对象的函数先

约束：heap要通过size达到限制heap_size的值

sweep之后就会得到free_list，相应的heap的size也要的拿回，这样改即可。

_________________划分线————————————————————————————————————
我重写了新建对象的方式，不再变得那么冗长了！

重写了heap，不再为数组，而是slice，后面都可以自由对象控制的数量了！

达成上面的条件，我就可以取设条件判断怎么让size取限定对象总数。

终于写完分配与合并了

由于用的结构体切片，所以在合并操作的流程上与书本有点区别，剩下的逻辑基本上没错，该改的都会自己改了，希望没问题吧。